/*
 *  WprofController.h
 *  WebCore
 *
 *  Created by Sophia Wang on 7/10/12.
 *  Copyright 2012 University of Washington. All rights reserved.
 *
 */
#ifndef WprofController_h
#define WprofController_h

//#if !WPROF_DISABLED

#include "Logging.h"
#include "ResourceLoadTiming.h"
#include "WprofData.h"
#include "WprofHTMLTag.h"
#include "WprofReceivedChunk.h"
#include "WprofResource.h"
#include "WprofComputation.h"
#include "WprofPreload.h"

namespace WebCore {
    
// Define the main object in which we store all the dependency (meta) information
class WprofController {
public:
        // Singleton creation and fetching
        static WprofController* getInstance() {
            static WprofController* m_pInstance;
            if (!m_pInstance)
                m_pInstance = new WprofController();
            return m_pInstance;
        };
        
        ~WprofController() {};
        
        // ---------------------------------------------------------------
        // Functions for Wprof* objects mutation
        // ---------------------------------------------------------------

	/*
	 * This function creates a WprofResource object.
	 * Called by ResourceLoader::didReceiveResponse().
	 * To save memory, WprofResource merges the <url, request time> mapping.
	 *
	 * @param TODO
	 */
        void createWprofResource(
	    unsigned long id,
	    String url,
	    RefPtr<ResourceLoadTiming> resourceLoadTiming,
	    String mime,
	    long long expectedContentLength,
	    int httpStatusCode,
	    unsigned connectionId,
	    bool connectionReused,
	    bool wasCached) {

            // Find request start time
            double time = m_wprofData->getTimeAndRemoveMapping(url);
            
            // Find the WprofHTMLTag that this resource is requested from if any
            // Note that image requested from CSS is considered later
            WprofHTMLTag* tag = m_wprofData->getRequestWprofHTMLTagByUrl(url);

	    WprofResource* resource = new WprofResource(id, url, resourceLoadTiming, mime, expectedContentLength, httpStatusCode, connectionId, connectionReused, wasCached, time, tag);
            
	    m_wprofData->updateOnCreateWprofResource(resource);
        }
        
	/*
	 * This function creates a WprofReceivedChunk object.
	 * Called by ResourceLoader::didReceiveData().
	 *
	 * @param unsigned long id of the corresponding request
	 * @param unsigned long length of the received chunk
	 */
        void createWprofReceivedChunk(unsigned long id_url, unsigned long length) {
	    WprofReceivedChunk* chunk = new WprofReceivedChunk(id_url, length, monotonicallyIncreasingTime());

	    m_wprofData->updateOnCreateWprofReceivedChunk(chunk, id_url, length);
        }

	/*
	 * This function adds a <url, request time> mapping.
	 * Called by ResourceLoader::willSendRequest().
	 * To save memory, especially that of the url, we should move this info to WprofResource
	 * a corresponding WprofResource object is created.
	 *
	 * @param const char request url
	 */
        void createRequestTimeMapping(String url) {
	    m_wprofData->updateOnCreateRequestTimeMapping(url);
        }

	/*
	 * This function creates a WprofHTMLTag object.
	 * Called by HTMLTreeBuilder::constructTreeFromToken().
	 *
	 * @param TextPosition textPosition of the tag
	 * @param String url of the document
	 * @param String token of the tag
	 * @param bool whether this is a start tag
	 */
	void createWprofHTMLTag(
	    TextPosition textPosition,
	    String docUrl,
	    String token,
	    bool isStartTag) {

	    WprofHTMLTag* tag = new WprofHTMLTag(
		textPosition,
		docUrl,
		token,
		monotonicallyIncreasingTime(),
		m_wprofData->charConsumed(),
		m_wprofData->charLen(),
		isStartTag
	    );

	    m_wprofData->updateOnCreateWprofHTMLTag(tag);
	}
        
	/*
	 * Create a WprofComputation object.
	 * Called by TODO
	 *
	 * @param int type of the WprofComputation
	 */
        WprofComputation* createWprofComputation(int type) {
	    WprofComputation* event = new WprofComputation(type, m_wprofData->tempWprofHTMLTag());
	    m_wprofData->updateOnCreateWprofComputation(event);

	    return event;
        }
        
	/*
	 * Create a WprofPreload object.
	 * Called by HTMLPreloadScanner::preload().
	 *
	 * @param String the preloaded url
	 */
        void createWprofPreload(String url) {
	    WprofPreload* preload = new WprofPreload(m_wprofData->tempWprofHTMLTag(), url);
	    m_wprofData->updateOnCreateWprofPreload(preload);
        }

        void createRequestWprofHTMLTagMapping(String url, WprofHTMLTag* tag) {
	    m_wprofData->onCreateRequestWprofHTMLTagMapping(url, tag);
        }
        
        void createRequestWprofHTMLTagMapping(String url) {
	    m_wprofData->onCreateRequestWprofHTMLTagMapping(url);
        }

        void setHTMLLinkRecalcStyle(String url) {
	    m_wprofData->setHTMLLinkRecalcStyle(url);
        }
        
        void setCharConsumed(int charConsumed, int charLen) {
            m_wprofData->setcharConsumed(charConsumed);
            m_wprofData->setCharLen(charLen);
        }
        
        void addCSSUrl(String url) {
	    m_wprofData->addCSSUrl(url);
        }
        
        void setCSSContentPair(WprofHTMLTag* key, String value) {
	    m_wprofData->setCSSContentPair(key, value);
        }

	WprofHTMLTag* tempWprofHTMLTag() {
	    return m_wprofData->tempWprofHTMLTag();
	}

	void setElementTypePair(WprofHTMLTag* key, int value) {
	    m_wprofData->setElementTypePair(key, value);
	}

	// ---------------------------------------------------------------
	// Output methods
	void increaseDomCounter() {
	    m_wprofData->increaseDomCounter();
	}

	void decreaseDomCounter(String url) {
	    m_wprofData->decreaseDomCounter(url);
	}
        
        // ------------------------------------
        // Functions for ???
        // ------------------------------------
/* 
        bool matchUnsimplifiedUrl(char* s, const char* url, unsigned int k) {
            //LOG(DependencyLog, "matchUnsimplifiedUrl %s %s %d", s, url, k);
            if (strlen(url) - k == strlen(s)) {
                // s should have been simplified, match directly
                unsigned int i = 0;
                while (i < strlen(url) - k) {
                    if (s[i] != url[i + k]) {
                        delete[] s;
                        return false;
                    }
                    i++;
                }
                delete[] s;
                return true;
            }
            
            // Simplify s
            // suppose that no hidden file can be fetched (file can't start with .)
            unsigned int i = 0, j = 0;
            unsigned int n = strlen(s);
            //LOG(DependencyLog, "matchUnsimplifiedUrl (%s %d)", s, n);
            
            // Get rid of multiple '/'
            while (j < n - 1) {
                if (s[j] == '/' && s[j + 1] == '/') {
                    // Ignore more than one slashes
                    ++j;
                    continue;
                }
                s[i++] = s[j++];
            }
            while (j < n)
                s[i++] = s[j++];
            n = i;
            //LOG(DependencyLog, "matchUnsimplifiedUrl (%s %d)", s, n);
            
            // Get rid of './'
            i = 0;
            j = 0;
            while (j < n - 1) {
                if (s[j] == '/' && s[j+1] == '.' && s[j+2] == '/') {
                    j += 2;
                }
                s[i++] = s[j++];
            }
            while (j < n)
                s[i++] = s[j++];
            n = i;
            //LOG(DependencyLog, "matchUnsimplifiedUrl (%s %d)", s, n);
            
            // Get rid of '../'
            i = 0;
            j = 0;
            while (j < n - 3) {
                if (s[j] == '/' && s[j+1] == '.' && s[j+2] == '.' && s[j+3] == '/') {
                    j += 3;
                    --i;
                    while (s[i] != '/' && i > 0)
                        --i;
                }
                s[i++] = s[j++];
            }
            while (j < n)
                s[i++] = s[j++];
            n = i;
            //LOG(DependencyLog, "matchUnsimplifiedUrl (%s %d)", s, n);
            
            // Match the cleaned urls
            i = 0;
            while (i < n && i < strlen(url) - k) {
                if (s[i] != url[i + k]) {
                    delete[] s;
                    return false;
                }
                ++i;
            }
            
            delete[] s;
            return true;
        }
        
        bool matchRelativeUrl(const char* url, const char* baseUrl, const char* css, unsigned int pos) {
            unsigned j = 0, k = 0, l = 0;
            
            // Sporadic checks to eliminate ineligible cases fast
            if (strlen(url) < 7 | strlen(baseUrl) < 7)
                return false;
            if (url[4] != baseUrl[4] || url[6] != baseUrl[6])
                return false;
            
            // Match baseUrl and url until the third '/' is reached
            // which basically indicates the directory of www server
            // e.g. http://piigeon.org/img/global256.png
            unsigned int num = 0; // indicates num of '/' in urls
            k = 0;
            while (url[k] == baseUrl[k] && num < 3) {
                if (url[k] == '/')
                    num++;
                k++;
            }
            k--;
            // Up to the home directory, they are matched
            // Note that k is the position of the third '/' that we now
            // save for future use
			
            if (num < 3)
                return false;
            
            char* s = NULL;
            
            // Figure out the length of the url in css
            l = pos; // index for css
            while (css[l] != '\'' && css[l] != '"' && css[l] != ')' && css[l] != ' ')
                l++;
            l -= pos;
            // Now the path of cssUrl starts at pos with a length of l
            
            // Now we apply the relative path rules to the url in css
            // Judge whether this the path in css is relative or absolute
            if (css[pos] != '/') {
                // The path is relative and we seek the last '/' in baseUrl.
                // The goal here is to concatenate the part in baseUrl and the part in cssUrl
                j = strlen(baseUrl) - 1; // index for baseUrl
                while (baseUrl[j] != '/')
                    --j;
                j -= k;
                // Now the first part starts at k with a length of j
                
                s = new char[j + l + 1];
                memcpy(s, baseUrl + k, j);
                memcpy(s + j, css + pos, l);
                s[j + l + 1] = '\0';
            } else {
                s = new char[l];
                memcpy(s, css + pos, l);
                s[l + 1] = '\0';
            }
            
            //LOG(DependencyLog, "matchRelativeUrl (s: %s)\n(url: %s %d)\n(baseUrl: %s %d %d)\n(css: %s %d %d)", s, url, k, baseUrl, k, j, css, pos, l);
            
            // Note that we need to delete[] s in matchUnsimplifiedUrl()
            return matchUnsimplifiedUrl(s, url, k);
        }
        
        void matchCSSImages() {
            // First, check whether there is image url that is made from css
            if (m_cssUrlVector->size() <= 0)
                return;
            
            // If any, init and construct this cache
            m_cssUrlPosCache = new HashMap<WprofHTMLTag*, Vector<int>*>();
            unsigned int i = 0;
            
            HashMap<WprofHTMLTag*, String>::iterator iter = m_cssContentMap->begin();
            WprofHTMLTag* tag = NULL;
            const char* s = NULL;
            for (; iter != m_cssContentMap->end(); ++iter) {
                // Figure out the positions of URL or url
                tag = iter->first;
                s = iter->second.utf8().data();
                i = 0;
                while (i < strlen(s) - 3) { // 3 = strlen("url")
                    // Sporadic checks to eliminate ineligible cases fast
                    if ((s[i] != 'u' && s[i] != 'U') || s[i+3] != '(') {
                        ++i;
                        continue;
                    }
                    
                    // if 'u' or 'U' is matched
                    if ((s[i+1] == 'r' && s[i+2] == 'l') || (s[i+1] == 'R' && s[i+2] == 'L')) {
                        
                        // Move it to the next char
                        i += 4;
                        
                        // Skip invalid chars
                        while (s[i] == ' ' || s[i] == '"' || s[i] == '\'') ++i;
                        
                        // Record i
                        if (!m_cssUrlPosCache->get(tag)) { // create a hash entry if not yet
                            m_cssUrlPosCache->set(tag, new Vector<int>);
                        }
                        m_cssUrlPosCache->get(tag)->append(i);
                    } else {
                        ++i;
                    }
                }
            }
            
            // Match urls with the cache
            unsigned int j = 0, k = 0, pos = 0;
            const char* url = NULL;
            const char* css = NULL;
            const char* baseUrl = NULL;
            bool matched = false;
            HashMap<WprofHTMLTag*, Vector<int>*>::iterator it;
            for (i = 0; i < m_cssUrlVector->size(); ++i) {
                // Fetch the url
                url = (*m_cssUrlVector)[i].utf8().data();
                
                it = m_cssUrlPosCache->begin();
                for (; it != m_cssUrlPosCache->end(); ++it) {
                    // Fetch the css
                    css = m_cssContentMap->get(it->first).utf8().data();
                    
                    for (j = 0; j < it->second->size(); ++j) {
                        pos = (*it->second)[j];
                        
                        // Start to match
                        // Note the case of relative paths...
                        matched = false;
                        k = 0;
                        
                        // First attempt, try to see whether the url in css is absolute
                        if (url[3] == css[3 + pos] && url[6] == css[6 + pos]) {
                            // url is absolute
                            while (k < strlen(url) && k + pos < strlen(css)) {
                                if (url[k] != css[k + pos]) {
                                    break;
                                }
                                k++;
                                if (k == strlen(url))
                                    matched = true;
                            }
                        } else {
                            
                            // Second attempt, match relative urls
                            //if (!matched) {
                            baseUrl = (it->first->m_url.utf8().data() == NULL) ? it->first->m_docUrl.utf8().data() : it->first->m_url.utf8().data();
                            
                            matched = matchRelativeUrl(url, baseUrl, css, pos);
                        }
                        
                        // Output if matched
                        if (matched) {
                            fprintf(stderr, "{\"matchedCSSAndUrl\": {\"code\": \"%p\", \"docUrl\": \"%s\", \"row\": %d, \"column\": %d, \"url\": \"%s\", \"imgUrl\": \"%s\"}}\n",
                                    it->first,
                                    it->first->m_docUrl.utf8().data(),
                                    it->first->m_textPosition.m_line.oneBasedInt(),
                                    it->first->m_textPosition.m_column.oneBasedInt(),
                                    it->first->m_url.utf8().data(),
                                    url
                                    );
                        }
                    }
                }
            }
        }
*/ 
private:
        WprofController(){
	    m_wprofData = new WprofData();
        };

	WprofData* m_wprofData;
};
    
}
//#endif // WPROF_DISABLED

#endif
