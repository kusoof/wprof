/*
 *  WprofData.h
 *  WebCore
 *
 *  Created by Sophia Wang on 7/10/12.
 *  Copyright 2012 University of Washington. All rights reserved.
 *
 */
#ifndef WprofData_h
#define WprofData_h

#include "Logging.h"
#include "ResourceLoadTiming.h"
#include "WprofHTMLTag.h"
#include "WprofReceivedChunk.h"
#include "WprofResource.h"
#include "WprofComputation.h"
#include "WprofPreload.h"

#include <wtf/HashMap.h>
#include <wtf/CurrentTime.h>
#include <wtf/MD5.h>
#include <wtf/Vector.h>
#include <wtf/text/CString.h>
#include <wtf/text/TextPosition.h>
#include <wtf/text/WTFString.h>

#if !WPROF_DISABLED

namespace WebCore {

// Utils used outside
class WprofData {
public:
        WprofData()
		: m_cssContentMap(NULL)
		, m_tempWprofHTMLTag(NULL)
		, m_charConsumed(0)
		, m_charLen(0)
		, m_HTMLLinkRecalcStyle(String::format(""))
		, m_domCounter(0)
		, m_url(String::format(""))
        {
            m_wprofResourceVector = new Vector<WprofResource*>;
            m_wprofResourceMap = new HashMap<unsigned long, WprofResource*>();
            m_requestTimeMap = new HashMap<String, double>();
            m_requestWprofHTMLTagMap = new HashMap<String, WprofHTMLTag*>();
            
            m_elemStartVector = new Vector<WprofHTMLTag*>;
            m_elemTypeMap = new HashMap<WprofHTMLTag*, int>();
            
            m_cssContentMap = new HashMap<WprofHTMLTag*, String>();
            m_cssUrlVector = new Vector<String>;
            
            m_wprofComputationVector = new Vector<WprofComputation*>;
            
            m_wprofPreloadVector = new Vector<WprofPreload*>;
        };

	// ---- The following methods are called by WprofController

	/*
	 * Called by WprofController::createWprofResource()
	 */
	void updateOnCreateWprofResource(WprofResource* resource) {
            m_wprofResourceVector->append(resource);
            m_wprofResourceMap->set(resource->getId(), resource);
	}

	/*
	 * Called by WprofController::createWprofReceivedChunk()
	 */
	void updateOnCreateWprofReceivedChunk(WprofReceivedChunk* chunk, unsigned long id_url, unsigned long length) {
            m_wprofResourceMap->get(id_url)->appendWprofReceivedChunk(chunk);
            m_wprofResourceMap->get(id_url)->addBytes(length);
	}

	/*
	 * Called by WprofController::createRequestTimeMapping()
	 */
	void updateOnCreateRequestTimeMapping(String url) {
            m_requestTimeMap->set(url, monotonicallyIncreasingTime());
	}

	/*
	 * Get the request time of a url and delete its corresponding mapping
	 *
	 * @param const char* request url
	 * @return double request time
	 */
        double getTimeAndRemoveMapping(String url) {
	    //double time = m_requestTimeMap->get(url);
	    // TODO figure out why get() doesn't work

	    double time = -1;
            HashMap<String, double>::iterator iter = m_requestTimeMap->begin();
            
            for (; iter != m_requestTimeMap->end(); ++iter) {
                if (url == iter->first) {
                    time = iter->second;
                }
            }

	    // Remove the item
	    // TODO figure out why remove() doesn't work
	    m_requestTimeMap->remove(url);
	    //fprintf(stderr, "m_requestTimeMap %s %d\n", url.utf8().data(), m_requestTimeMap->size());

	    return time;
        }
        
        WprofHTMLTag* getRequestWprofHTMLTagByUrl(String url) {
            HashMap<String, WprofHTMLTag*>::iterator iter = m_requestWprofHTMLTagMap->begin();
            
            for (; iter != m_requestWprofHTMLTagMap->end(); ++iter) {
                if (url == iter->first) {
                    return iter->second;
                }
            }

	    // TODO delete after it is fetched to save memory
            return NULL;
        }

	void updateOnCreateWprofHTMLTag(WprofHTMLTag* tag) {
	    // Add WprofHTMLTag to its vector
            for (unsigned int i = 0; i < m_wprofResourceVector->size(); ++i) {
                WprofResource* resource = (*m_wprofResourceVector)[i];
                if (resource->url() == tag->docUrl()) {
                    resource->appendDerivedWprofHTMLTag(tag);
                    return;
                }
            }

	    // Set tempWprofHTMLTag
            m_tempWprofHTMLTag = tag;
            
            // We clear this because this is only valid for current HTMLLinkElement
            // TODO to be verified
            m_HTMLLinkRecalcStyle = String::format("");

	    if (tag->isStartTag()) {
		// Add tag to the start vector
                m_elemStartVector->append(tag);

		if (tag->tagName() == String::format("script")) {
            	    // Add tag to tempWprofHTMLTag for EndTag
                    // This works because there is no children inside elements
                    // we care about (<script>, <link> and <style>)

                    // Set type as normal. We will change it if async or defer
		    setElementTypePair(tag, 1); // normal
		}
	    }
	}

	void updateOnCreateWprofComputation(WprofComputation* event) {
            m_wprofComputationVector->append(event);
	}

	void updateOnCreateWprofPreload(WprofPreload* preload) {
            m_wprofPreloadVector->append(preload);
	}

	void onCreateRequestWprofHTMLTagMapping(String url, WprofHTMLTag* tag) {
            m_requestWprofHTMLTagMap->set(url, tag);
	}

	void onCreateRequestWprofHTMLTagMapping(String url) {
            m_requestWprofHTMLTagMap->set(url, tempWprofHTMLTag());
	}

	void setHTMLLinkRecalcStyle(String url) {
            m_HTMLLinkRecalcStyle = url;
	}

	void setcharConsumed(int charConsumed) {
	    m_charConsumed = charConsumed;
	}

	void setCharLen(int charLen) {
	    m_charLen = charLen;
	}

	void addCSSUrl(String url) {
            m_cssUrlVector->append(url);
	}

	void setCSSContentPair(WprofHTMLTag* key, String value) {
            if (key == NULL || value == String::format(""))
                return;
            
            // Should check whether key has existed
            HashMap<WprofHTMLTag*, String>::iterator iter = m_cssContentMap->begin();
            for (; iter != m_cssContentMap->end(); ++iter) {
                if (*key == *iter->first) {
                    m_cssContentMap->set(iter->first, value);
                    return;
                }
            }
            m_cssContentMap->set(key, value);
	}

	// ---- End
        
        // TODO public For temporarily stored obj hash
        WprofHTMLTag* tempWprofHTMLTag() {
	    return m_tempWprofHTMLTag;
	}
        
        void setElementTypePair(WprofHTMLTag* key, int value) {
            if (key == NULL)
                return;
            
            // Should check whether key has existed
            HashMap<WprofHTMLTag*, int>::iterator iter = m_elemTypeMap->begin();
            for (; iter != m_elemTypeMap->end(); ++iter) {
                if (*key == *iter->first) {
                    m_elemTypeMap->set(iter->first, value);
                    return;
                }
            }
            m_elemTypeMap->set(key, value);
        }

        // ---------------------------------------------------------------
        // Output methods
        
        // Increase/decrease DOM counter, called in Document.cpp
        void increaseDomCounter() {
	    m_domCounter++;
	}
        
        void decreaseDomCounter(String url) {
            m_domCounter--;
            
            if (m_domCounter > 0) {
		return;
	    }
            if (url.length() < 5) {
                clear();
                return;
            }
                
	    if (!url.startsWith("http")) {
            //if (url[0] != 'h' || url[2] != 't' || url[3] != 'p') {
                clear();
                return;
            }
                
            // Now we should have doc that only begins with http
            m_url = createFilename(url);
	    LOG(DependencyLog, "WprofController::decreaseCounter %s", m_url.utf8().data());
                
            // Clear maps
            output();
	    clear();
        }
        
        int charConsumed() { return m_charConsumed; }
        int charLen() { return m_charLen; }
        
private:
        String createFilename(String url) {
            // Skip http:// or https://
	    url.replace("http://", "");
	    url.replace("https://", "");
            
            // Escape illegal chars as a file name
	    url.replace(":", "_");
	    url.replace("/", "_");
	    return url;
        }
        
        // Output
        void output() {
            // Record the timestamp of the 'load' event
            fprintf(stderr, "{\"page\": \"%s\"}\n", m_url.utf8().data());
            fprintf(stderr, "{\"DOMLoad\": %lf}\n", monotonicallyIncreasingTime());

            outputWprofResource();
            outputHOLMaps();
            outputCSSImageMaps();
            outputWprofComputations();
            outputWprofPreloads();
			
	    fprintf(stderr, "{\"Complete': \"%s\"}\n", m_url.utf8().data());
        }
        
        void outputWprofResource() {
            for (unsigned int i = 0; i < m_wprofResourceVector->size(); ++i) {
                // Output one resource info
                WprofResource* info = (*m_wprofResourceVector)[i];
                
                RefPtr<ResourceLoadTiming> timing = info->resourceLoadTiming();
                
                if (!timing)
                    fprintf(stderr, "{\"Resource\": {\"id\": %ld, \"url\": \"%s\", \"sentTime\": %lf, \"len\": %ld, \"from\": \"%p\",\
                            \"mimeType\": \"%s\", \"contentLength\": %lld, \"httpStatus\": %d, \"connId\": %u, \"connReused\": %d, \"cached\": %d}}\n",
                            info->getId(),
                            info->url().utf8().data(),
                            info->timeDownloadStart(),
                            info->bytes(),
                            info->fromWprofHTMLTag(),
                            info->mimeType().utf8().data(),
                            info->expectedContentLength(),
                            info->httpStatusCode(),
                            info->connectionId(),
                            info->connectionReused(),
                            info->wasCached()
                            );
                else
                    fprintf(stderr, "{\"Resource\": {\"id\": %ld, \"url\": \"%s\", \"sentTime\": %lf, \"len\": %ld, \"from\": \"%p\",\
                            \"mimeType\": \"%s\", \"contentLength\": %lld, \"httpStatus\": %d, \"connId\": %u, \"connReused\": %d, \"cached\": %d,\
                            \"requestTime\": %f, \"proxyStart\": %d, \"proxyEnd\": %d, \"dnsStart\": %d, \"dnsEnd\": %d, \"connectStart\": %d, \"connectEnd\": %d, \"sendStart\": %d, \"sendEnd\": %d, \"receiveHeadersEnd\": %d, \"sslStart\": %d, \"sslEnd\": %d}}\n",
                            info->getId(),
                            info->url().utf8().data(),
                            info->timeDownloadStart(),
                            info->bytes(),
                            info->fromWprofHTMLTag(),
                            info->mimeType().utf8().data(),
                            info->expectedContentLength(),
                            info->httpStatusCode(),
                            info->connectionId(),
                            info->connectionReused(),
                            info->wasCached(),
                            timing->requestTime,
                            timing->proxyStart,
                            timing->proxyEnd,
                            timing->dnsStart,
                            timing->dnsEnd,
                            timing->connectStart,
                            timing->connectEnd,
                            timing->sendStart,
                            timing->sendEnd,
                            timing->receiveHeadersEnd,
                            timing->sslStart,
                            timing->sslEnd
                    );
                
                // Output info of received data chunks
                Vector<WprofReceivedChunk*>* v = info->receivedChunkInfoVector();
                for (unsigned int j = 0; j < v->size(); ++j) {
                    WprofReceivedChunk* chunkInfo = (*v)[j];
                    fprintf(stderr, "{\"ReceivedChunk\": {\"receivedTime\": %lf, \"len\": %ld}}\n",
                            chunkInfo->time(),
                            chunkInfo->len()
                    );
                }
                
                // Output info of parsed objects
                Vector<WprofHTMLTag*>* vWprofHTMLTag = info->derivedWprofHTMLTagVector();
                for (unsigned int j = 0; j < vWprofHTMLTag->size(); ++j) {
                    WprofHTMLTag* tag = (*vWprofHTMLTag)[j];
                    fprintf(stderr, "{\"WprofHTMLTag\": {\"code\": \"%p\", \"doc\": \"%s\", \"row\": %d, \"column\": %d, \"tagName\": \"%s\", \"time\": %lf, \"url\": \"%s\", \"pos\": %d, \"chunkLen\": %d, \"isStartTag\": %d}}\n",
                            tag,
                            tag->docUrl().utf8().data(),
                            tag->pos().m_line.oneBasedInt(),
                            tag->pos().m_column.oneBasedInt(),
                            tag->tagName().utf8().data(),
                            tag->time(),
                            tag->url().utf8().data(),
                            tag->startTagEndPos(),
                            tag->chunkLen(),
                            tag->isStartTag()
                    );
                }
            }
        }
        
        void outputHOLMaps() {
            // Output start tag vectors
            unsigned int i = 0;
            for (; i < m_elemStartVector->size(); i++) {
                WprofHTMLTag* startObjHash = (*m_elemStartVector)[i];
                
                if (startObjHash == NULL)
                    continue;
                
                // Skip non-script and non-css
                if (!m_elemTypeMap->get(startObjHash))
                    continue;
                
                TextPosition pos_s = startObjHash->m_textPosition;
                fprintf(stderr, "{\"HOL\": {\"type\": %d, \"docUrl\": \"%s\", \"code\": \"%p\", \"row\": %d, \"column\": %d, \"url\": \"%s\"}}\n",
                        m_elemTypeMap->get(startObjHash),
                        startObjHash->m_docUrl.utf8().data(),
                        startObjHash,
                        pos_s.m_line.oneBasedInt(),
                        pos_s.m_column.oneBasedInt(),
                        startObjHash->m_url.utf8().data()
                        );
            }
        }
        
        void outputCSSImageMaps() {
            // First, match!
            //matchCSSImages();
	    // TODO !
        }
        
        void outputWprofComputations() {
            for (unsigned int i = 0; i < m_wprofComputationVector->size(); ++i) {
                WprofComputation* event = (*m_wprofComputationVector)[i];
                
				if (event == NULL)
					continue;
				
                if (event->fromWprofHTMLTag() == NULL)
                    continue;
                
                // m_tempWprofHTMLTag->docUrl() indicates current url
                //if (strcmp(event->fromWprofHTMLTag()->docUrl(), m_tempWprofHTMLTag->docUrl()) == 0)
                //	continue;
                
                fprintf(stderr, "{\"Computation\": {\"type\": \"%s\", \"code\": \"%p\", \"docUrl\": \"%s\", \"startTime\": %lf, \"endTime\": %lf, \"urlRecalcStyle\": \"%s\"}}\n",
                        event->getTypeForPrint().utf8().data(),
                        event->fromWprofHTMLTag(),
                        event->fromWprofHTMLTag()->docUrl().utf8().data(),
                        event->startTime(),
                        event->endTime(),
                        event->urlRecalcStyle().utf8().data()
                );
            }
        }
        
        void outputWprofPreloads() {
            for (unsigned int i = 0; i < m_wprofPreloadVector->size(); ++i) {
                WprofPreload* pr = (*m_wprofPreloadVector)[i];
                
                if (pr->fromWprofHTMLTag() == NULL)
                    continue;
				
                fprintf(stderr, "{\"Preload\": {\"code\": \"%p\", \"docUrl\": \"%s\", \"url\": \"%s\", \"time\": %lf}}\n",
                        pr->fromWprofHTMLTag(),
                        pr->fromWprofHTMLTag()->docUrl().utf8().data(),
                        pr->url().utf8().data(),
                        pr->time()
                );
            }
        }

	void clear() {
            m_wprofResourceVector->clear();
            m_wprofResourceMap->clear();
            m_requestTimeMap->clear();
            m_requestWprofHTMLTagMap->clear();

            m_elemStartVector->clear();
            m_elemTypeMap->clear();

            m_cssContentMap->clear();
            m_cssUrlVector->clear();

            m_wprofComputationVector->clear();

            m_wprofPreloadVector->clear();
	}
        
        // CSS -> Image doesn't need this because this kind of dependency is
        // inferred by text matching
        void clearElementStartVector() {
            m_elemStartVector->clear();
            ASSERT(m_elemStartVector->isEmpty());
        }
        
        // ---------------------------------------------------------------
        // Methods for CSS elements (images could be requested from CSS)
        
        void clearCSSUrlVector() {
            m_cssUrlVector->clear();
            ASSERT(m_cssUrlVector->isEmpty());
        }

        // -------- WprofResource
        // All info we need for a resource
        // We store by both a vector and a hash with id of url as the key
        Vector<WprofResource*>* m_wprofResourceVector;
        // <id, WprofResource>
        HashMap<unsigned long, WprofResource*>* m_wprofResourceMap;
        // This is ugly but creating WprofResource in ResourceLoader::willSendRequest
        // results in a pointer bug. Thus, we create this map in ResourceLoader::willSendRequest
        // and match it with WprofResource later.
        // <url, request time>
        HashMap<String, double>* m_requestTimeMap;
        // This is to store the information of a url that is made from a WprofHTMLTag
        // to infer dependency. Because this occurs before a request is made, we need
        // to separately store it rather than storing it in WprofResource which is similar
        // to m_requestTimeMap
        HashMap<String, WprofHTMLTag*>* m_requestWprofHTMLTagMap;
        
        // -------- output dependencies
        // Output (Head-of-line) dependencies: only CSS and JS are taken into account.
        // CSS blocks following s_exec(JS) until e_parse(CSS)
        // JS:
        // - normal: both download and exec block parsing
        // - defer:  s_exec triggered by dom load
        // - async:  s_exec triggered by e_download
        // See WebCore/html/parser/HTMLTreeBuilder.cpp for more details
        Vector<WprofHTMLTag*>* m_elemStartVector; // s_download(element) > position
        HashMap<WprofHTMLTag*, int>* m_elemTypeMap; // 1: normal; 2: defer; 3: async; 4: CSS
        
        // -------- lazy binding
        // To track how images are fetched from css, we create this hash map so that
        // we can match the urls at this level. We do not pass WprofHTMLTag to each CSSValue
        // or CSSProperty because 1) it is too expensive to do so; 2) it requires us to
        // change a lot of code.
        HashMap<WprofHTMLTag*, String>* m_cssContentMap;
        // They are img urls (from CSSImageValue) for matching.
        // Note that we set two urls (partial and complete) at a time.
        Vector<String>* m_cssUrlVector;
        //HashMap<WprofHTMLTag*, Vector<int>*>* m_cssUrlPosCache;
        
        // -------- WprofComputation
        // Track computational events when what triggers them
        // This includes "recalcStyle", "layout" and "paint"
        Vector<WprofComputation*>* m_wprofComputationVector;
        
        // -------- eager binding
        // Track preload_scanner
        Vector<WprofPreload*>* m_wprofPreloadVector;
        
        // -------- for fast retrieval
        // Temp WprofHTMLTag
        WprofHTMLTag* m_tempWprofHTMLTag;
        int m_charConsumed;
        int m_charLen;
        String m_HTMLLinkRecalcStyle;
        
        // DOM counters so as to control when to output info
        int m_domCounter;
        String m_url; // document location, used as file name
};

}
#endif // WPROF_DISABLED

#endif
